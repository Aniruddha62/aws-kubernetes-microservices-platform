name: CI/CD Pipeline - DevOps Platform

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  EKS_CLUSTER_NAME: devops-platform-cluster
  K8S_NAMESPACE: devops-platform

jobs:
  # ─── Test & Build ───────────────────────────────────────────────────────────
  test-and-build:
    name: Test & Build Services
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [api-gateway, user-service, product-service, order-service, notification-service]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Java 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven

    - name: Run tests and build
      working-directory: services/${{ matrix.service }}
      run: mvn clean verify -DskipTests=false

    - name: Upload JAR artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.service }}-jar
        path: services/${{ matrix.service }}/target/*.jar
        retention-days: 1

  # ─── Frontend Build ──────────────────────────────────────────────────────────
  test-frontend:
    name: Test & Build Frontend
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    - run: cd frontend && npm ci
    - run: cd frontend && npm run build

  # ─── Docker Build & Push ─────────────────────────────────────────────────────
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: [test-and-build, test-frontend]
    if: github.ref == 'refs/heads/main'
    strategy:
      matrix:
        service: [api-gateway, user-service, product-service, order-service, notification-service, frontend]
    steps:
    - uses: actions/checkout@v4

    - name: Download JAR (for backend services)
      if: matrix.service != 'frontend'
      uses: actions/download-artifact@v4
      with:
        name: ${{ matrix.service }}-jar
        path: services/${{ matrix.service }}/target/

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      env:
        IMAGE_TAG: ${{ github.sha }}
      run: |
        SERVICE_DIR=${{ matrix.service == 'frontend' && 'frontend' || format('services/{0}', matrix.service) }}
        docker build -t $ECR_REGISTRY/${{ matrix.service }}:$IMAGE_TAG $SERVICE_DIR
        docker tag $ECR_REGISTRY/${{ matrix.service }}:$IMAGE_TAG $ECR_REGISTRY/${{ matrix.service }}:latest
        docker push $ECR_REGISTRY/${{ matrix.service }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ matrix.service }}:latest
        echo "image=$ECR_REGISTRY/${{ matrix.service }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

  # ─── Deploy to EKS ────────────────────────────────────────────────────────────
  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME

    - name: Apply Kubernetes manifests
      run: |
        kubectl apply -f k8s/namespaces/
        kubectl apply -f k8s/configmaps/
        kubectl apply -f k8s/deployments/
        kubectl apply -f k8s/services/
        kubectl apply -f k8s/ingress/
        kubectl apply -f k8s/hpa/

    - name: Update image tags
      env:
        IMAGE_TAG: ${{ github.sha }}
      run: |
        for service in api-gateway user-service product-service order-service notification-service frontend; do
          kubectl set image deployment/$service \
            $service=$ECR_REGISTRY/$service:$IMAGE_TAG \
            -n $K8S_NAMESPACE
        done

    - name: Wait for rollout
      run: |
        for service in api-gateway user-service product-service order-service notification-service frontend; do
          kubectl rollout status deployment/$service -n $K8S_NAMESPACE --timeout=300s
        done

    - name: Verify deployments
      run: kubectl get pods -n $K8S_NAMESPACE

  # ─── Notify ──────────────────────────────────────────────────────────────────
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    steps:
    - name: Notify success
      if: needs.deploy.result == 'success'
      run: echo "Deployment to EKS succeeded! All 5 services deployed."
    - name: Notify failure
      if: needs.deploy.result == 'failure'
      run: echo "Deployment failed! Check logs above."
